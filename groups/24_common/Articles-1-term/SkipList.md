# Skip List: Вероятностная альтернатива сбалансированным деревьям 
### Выполнила: Фомина Ульяна 11и1 


## Введение
Мы привыкли, что если нам нужен быстрый поиск, вставка и удаление данных за логарифмическое время O(log n), мы используем сбалансированные деревья поиска (например, AVL-деревья или Красно-черные деревья).\
Они эффективны, но их реализация очень сложна: сложные повороты, балансировка, перекрашивание узлов.
А что, если я скажу вам, что можно получить ту же производительность O(log n), но используя обычные связные списки и... монетку!
\
\
Я выбрала Skip List, потому что это идеальный пример того, как простая идея, така как рандомизация, побеждает сложную детерминированную логику.
Это структура используется во многих базах данных.

## Что такое Skip List?
**Skip List** — это вероятностная структура данных, основанная на нескольких параллельных отсортированных связных списках.
Представьте себе обычный отсортированный связный список. Чтобы найти в нем число, нам нужно пройтись по каждому элементу. Это долго — O(n).

### Основная идея:
Структура строится слоями. Нижний слой (уровень 0) — это обычный упорядоченный связный список, содержащий все элементы. Каждый последующий уровень $i$ является «разреженной» версией уровня $i-1$.\
Каждый элемент, присутствующий на уровне $i$, с определенной вероятностью $p$ (обычно $1/2$ или $1/4$) дублируется на уровень $i+1$. \
Таким образом, верхние уровни содержат меньше элементов и служат индексами для быстрого перемещения по нижним уровням. \
Поиск осуществляется путем движения по самому верхнему (максимально разреженному) списку до тех пор, пока не будет найден интервал, содержащий искомое значение, после чего происходит спуск на уровень ниже для уточнения позиции.\
Этот принцип позволяет «перепрыгивать» через большие блоки данных, что сокращает количество сравнений с $O(n)$ до $O(\log n)$. 


## Визуализация структуры

![Визуализация структуры Skip List](https://astikanand.github.io/techblogs/advanced-data-structures/assets/skip_list.png)



## История создания
Структура была представлена **Уильямом Пью** в статье "Skip Lists: A Probabilistic Alternative to Balanced Trees", опубликованной в журнале Communications of the ACM в **июне 1990 года**.
В своей работе он написал, что списки с пропусками — это вероятностная структура данных, которая вытеснит сбалансированные деревья в качестве метода реализации для многих приложений.
Его мотивация была проста: сбалансированные деревья (AVL, 2-3 деревья) теоретически хороши, но на практике их сложно программировать. Skip List предлагает те же характеристики, но с гораздо более простой реализацией.

## Как устроен Skip List 
1. **Вероятностная природа (Выбор уровня)** \
В отличие от деревьев, где структура строго определена, здесь высота узла определяется случайно при вставке.
*Алгоритм выбора уровня:*
Мы подбрасываем монетку с вероятностью $p$.
Пока выпадает "успех" (с вероятностью $p$), мы увеличиваем уровень узла.
Как только выпадает "неудача", мы останавливаемся. \
**Какое $p$ выбрать?** \
В оригинальной статье Пью анализирует два варианта: \
*p = 1/2:* Стандартный вариант. Экономит память меньше, но уровней меньше. \
*p = 1/4:* Рекомендация автора. Хотя высота дерева слегка увеличивается, это экономит указатели и улучшает константные факторы производительности в большинстве случаев. \
Максимальный уровень (MaxLevel): \
Автор рекомендует ограничивать высоту формулой $L(N) = \log_{1/p} N$. Например, для $p=1/2$ и $N=65536$ элементов, достаточно уровня 16. 
2. **Основные операции** \
**Поиск**: Начинаем с верхнего уровня. Если следующий элемент меньше искомого — идем вправо. Если больше — спускаемся вниз.\
**Вставка**: Сначала находим место для вставки. Затем генерируем случайный уровень для нового элемента. Перенаправляем указатели ("сшиваем" список) на всех уровнях высоты нового элемента.\
**Удаление**: Находим элемент и перенаправляем указатели его предшественников в обход него (как в обычном связном списке, но на всех уровнях).


## Сложность и анализ
|Операция|Средний случай|Худший случай|
|---|----|----|
|Поиск|$O(\log n)$|$O(n)$|
|Вставка|$O(\log n)$|$O(n)$|
|Удаление|$O(\log n)$|$O(n)$|
|Память|$O(n)$|$O(n \cdot \log n)$|

Вот как это выглядит схематично. Пусть мы ищем число 80:

![Визуализация структуры Skip List](https://upload.wikimedia.org/wikipedia/commons/d/da/Skip_list_add_element.gif)

**Путь поиска:** \
Head(L4) -> 80 <= 30? Ложь, дальше цифр нет, значит спускаемся ниже. -> \
-> Head(L3) -> 80 <= 50? Ложь, дальше цифр нет, спускаемся ниже. -> \
-> Head(L2) -> 80 <= 70? Ложь, дальше цифр нет, спускаемся ниже.-> \
-> Head(L1) -> 80 <= 90? Истина! мы нашли место, куда надо вставить 80. Вставляем число после 70 на каждом уровне. 

## Доказательство (Обратный анализ)
Как мы уже знаем, поиск занимает $O(\log n)$. \
**Докажем это методом "обратного анализа"** \
Представим, что мы идем от найденного элемента обратно к началу списка (вверх и влево).\
В любой точке мы можем пойти либо вверх (если пришли с верхнего уровня), либо влево.\
Вероятность пойти вверх равна $p$.\
Это означает, что в среднем нам нужно $1/p$ шагов влево, чтобы подняться на 1 уровень.\
Так как всего уровней $O(\log n)$, общее число шагов $T(n) = \frac{1}{p} \times O(\log n) = O(\log n)$.

*Насколько вероятен худший случай?*\
Кажется: **"А вдруг монетка всегда будет выдавать решку?"** \
Уильям Пью в своей статье приводит такой довод: \
«Для списка из более чем 250 элементов вероятность того, что поиск займет в 3 раза больше времени, чем ожидается, составляет менее одного на миллион».

## Сравнение с аналогами
В оригинальной работе Пью сравнивает Skip List с другими структурами:\
**AVL-деревья**: Skip List сравним по скорости, но выигрывает в простоте реализации. В тестах автора на вставку/удаление Skip List был быстрее рекурсивных реализаций 2-3 деревьев.\
**Splay Trees**: Splay-деревья выигрывают при неравномерных запросах (когда мы часто ищем одно и то же). Но для случайных равномерных запросов Skip List работает быстрее из-за меньших накладных расходов.


## Мотивация использования сегодня
**Почему *Redis* и *RocksDB* используют Skip List, а не деревья?** \
**Эффективный поиск** — вместо последовательного поиска элемента в списке можно эффективно пропускать узлы, что ускоряет поиск. \
**Простота реализации** — skip lists не требуют сложной балансировки после каждой вставки и удаления, в то время как деревья требуют сложной балансировки. \
**Быстрая вставка и удаление** — skip lists поддерживают быстрые операции вставки, удаления и поиска. \
**Эффективные запросы диапазона** - skip lists особенно эффективны для запросов диапазона, что важно для отсортированных наборов.

# Заключение
Skip List — это очень удобный инструмент для обработки больших данных, например, нахождения всех отрезков чисел, перекрывающих какую-либо точку. \
Используя простую рандомизацию, мы получаем структуру данных, которая работает так же быстро, как сложные деревья, но гораздо проще в поддержке и параллелизации. 

## Использованные источники
Pugh, W. (1990). "Skip Lists: A Probabilistic Alternative to Balanced Trees". Communications of the ACM. https://homepage.divms.uiowa.edu/~ghosh/skip.pdf \
Списки с пропусками. https://ru.wikipedia.org/wiki/Список_с_пропусками \
Skip list. https://astikanand.github.io/techblogs/advanced-data-structures/skip-list 

# Пример реализации (https://astikanand.github.io/)
```python
from random import random

class Node:
    def __init__(self, key, level):
        self.key = key
        self.next = [None]*(level+1)

class SkipList:
    def __init__(self, max_level, P):
        # Maximum level for this skip list
        self.max_level = max_level
        # P is the fraction of the nodes with level i references also having level i+1 references
        self.P = P
        # create head node and initialize key to -1
        self.head = Node(-1, max_level)
        # temp level of skip list 
        self.level = 0


    def get_random_level(self): 
        lvl = 0
        while random() < self.P and lvl < self.max_level:
            lvl += 1
        return lvl
    

    def insert_key(self, key):
        # create update array and initialize it 
        update = [None]*(self.max_level+1) 
        temp = self.head

        # start from highest level of skip list move the temp reference next while key  
        # is greater than key of node next to temp, Otherwise inserted temp in update and  
        # move one level down and continue search.
        for i in range(self.level, -1, -1): 
            while temp.next[i] and temp.next[i].key < key: 
                temp = temp.next[i] 
            update[i] = temp
        
        # reached level 0, now get the node next to temp, need to insert b/w temp and next_node
        next_node = temp.next[0]

        # if next_node is NULL that means we have reached to end of the level or 
        # if next_node's key != key to insert that means we have to insert node between update[0] and next_node
        if next_node == None or next_node.key != key:
            # Generate a random level for node 
            random_level = self.get_random_level()

            # If random level is greater than list's next_node level 
            # (node with highest level inserted in list so far),
            # initialize update value with reference to head for further use 
            if random_level > self.level: 
                for i in range(self.level+1, random_level+1): 
                    update[i] = self.head
                self.level = random_level
            
            # create new node with random level generated
            new_node = Node(key, random_level)

            # insert node by rearranging references  
            for i in range(random_level+1): 
                new_node.next[i] = update[i].next[i] 
                update[i].next[i] = new_node
  
            print(key, end=" ")


    def display_list(self): 
        print("\n\nFinal Skip List Level wise:") 
        head = self.head 
        for lvl in range(self.level+1): 
            print("Level - [{}]: ".format(lvl), end=" ") 
            node = head.next[lvl] 
            while(node != None): 
                print(node.key, end=" ") 
                node = node.next[lvl] 
            print()


#Driver Program
print("Skip List Example:")
lst = SkipList(3, 0.5)
print("Insert Keys: ", end=" ")
lst.insert_key(3) 
lst.insert_key(6) 
lst.insert_key(7) 
lst.insert_key(9) 
lst.insert_key(12) 
lst.insert_key(19) 
lst.insert_key(17) 
lst.insert_key(26) 
lst.insert_key(21) 
lst.insert_key(25)
lst.display_list()
```

## Вывод:
Skip List Example: \
Insert Keys:  3 6 7 9 12 19 17 26 21 25 

Final Skip List Level wise: \
Level - [0]:  3 6 7 9 12 17 19 21 25 26 \
Level - [1]:  6 9 12 17 21 \
Level - [2]:  6 21 \
Level - [3]:  6 21 
